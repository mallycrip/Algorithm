# Merge Sort
분할 하여 문제를 해결하고 결과를 모아서 정렬하는 알고리즘
## Detail
리스트를 __두 개의 균등한 균등한 크기__ 로 분할 후, `분할 된 부분 리스트`를 정렬한 다음, `두 개의 정렬 된 부분 리스트`를 합하여 전체가 정렬된 리스트가 되게 하는 방법.

### Example
__8, 2, 4, 1, 3, 7, 5, 6__<br/>
<br/>
__8, 2, 4, 1__<br/>
<br/>
__8, 2__<br/>
`8` | `2` -> 2 <br/>
`8` | -> 2, 8 <br/>
Result = 2, 8<br/>
<br/>
__4, 1__<br/>
`4` | `1` -> 1<br/>
`4` | -> 1, 4<br/>
Result = 1, 4<br/>
<br/>
`2`, 8  |  `1`, 4 -> 1 <br/>
`2`, 8  |  `4` -> 1, 2 <br/>
`8`  |  `4` -> 1, 2, 4 <br/>
`8`  |  -> 1, 2, 4, 8 <br/>

Result = 1, 2, 4, 8<br/>

__3, 7, 5, 6__<br/>
<br/>
__3, 7__<br/>
`3` | `7` -> 3 <Br/>
| `7` -> 3, 7<br/>
Result = 3, 7<br/>
<br/>
__5, 6__<br/>
`5` | `6` -> 5 <br/>
| `6` -> 5, 6<br/>
Result = 5, 6<br/>
<br/>
`3`, 7 | `5`, 6 -> 3 <br/>
`7` | `5`, 6 -> 3, 5 <br/>
`7` | `6` -> 3, 5, 6 <br/>
`7` | -> 3, 5, 6, 7 <br/>
Result = 3, 5, 6, 7<br/>
<br/>
`1`, 2, 4, 8 | `3`, 5, 6, 7 -> 1<br/>
`2`, 4, 8 | `3`, 5, 6, 7 -> 1, 2<br/>
`4`, 8 | `3`, 5, 6, 7 -> 1, 2, 3<br/>
`4`, 8 | `5`, 6, 7 -> 1, 2, 3, 4<br/>
`8` | `5`, 6, 7 -> 1, 2, 3, 4, 5<br/>
`8` | `6`, 7 -> 1, 2, 3, 4, 5, 6<br/>
`8` | `7` -> 1, 2, 3, 4, 5, 6, 7<br/>
`8` |  -> 1, 2, 3, 4, 5, 6, 7, 8<br/>
<br/>
Result = 1, 2, 3, 4, 5, 6, 7, 8

## Time Complexity
T(n) = O(nlog2(n))

## Advantage / Disadvantage
### Advantage
- 안정적인 정렬 방법이다.
  - 데이터의 분포에 영향을 덜 받는다. 즉 입력 데이터가 무엇이든 간에 정렬되는 시간은 동일하다
- `연결 리스트`로 구성 시, 링크 인덱스만 변경 되므로 데이터의 이동은 무시할 수 있을 정도로 작아진다.
  - 제자리 정렬로 구현이 가능하다
- 크기가 큰 레코드를 정렬할 경우에 `연결 리스트`를 사용한다면 `Merge Sort`가 가장 효율적이다

### Disadvantage
- `배열`로 구현시 임시 배열이 필요하다.
  - 제자리 정렬이 아니다.
- 레코드의 크기가 큰 경우 이동 횟수가 많아져 매우 큰 시간적 낭비가 생긴다.
